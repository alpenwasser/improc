#!/usr/bin/perl
use warnings;
use strict;

use 5.10.0;
use GD;
use GD::Text::Align;
use File::Basename;		# dirname(),fileparse(),basename()
use Getopt::Long;


my $logo;
my $DESIRED_W;
my $DESIRED_H;
my @source_files;
my @trim; # Trim factors: (top, right, bottom, left)
my @SUFFIX_LIST = (".jpeg",".png",".jpg");
my @IMG_FILES;
my $overwrite = 0;




# TODO: refactor
#       add capability to specify output file format
#       add capability to specify logo size
#       add capability to specify logo placement


# Based on a square logo 1/10 the width of a 1.5/1 image:
my $logo_area_ratio = 0.0225;

sub get_input_args
{
	# Get input from command line.
	

	my $arg_parser = Getopt::Long::Parser->new();
	$arg_parser->getoptions(
		"logo|l=s"     => \$logo,
		"width|w=i"    => \$DESIRED_W,
		"height|h=i"   => \$DESIRED_H,
		"files|f=s{,}" => \@source_files,
		"trim|t=s{,}"  => \@trim,
		"overwrite|o!" => \$overwrite
	) or die ("Insufficient arguments");


	die("No image files specified.") unless (@source_files);
}




sub validate_trim_factors
{
        # Validate trim array...
	if (scalar(@trim) == 0)
	{
		@trim=(0,0,0,0);
	}

	if (scalar(@trim) < 4)
	{
		say "NOTE: Too few trim arguments specified. "
		  . "Assuming zero for unspecified elements. ";

		# Pad array with zeroes.
		push @trim, 0 until (scalar(@trim) == 4);
	}
	elsif (scalar(@trim > 4))
	{
		say "NOTE: Too many trim arguments specified. "
		  . "Removing excess elements. ";

		# Remove excess elements.
		pop @trim until (scalar(@trim) == 4);
	}

	foreach (@trim)
	{
		# Trim values are relative  to image size, so values
		# between 0 and 1 make sense.
		die("Trim values must be between 0 and 1, invalid range specified.") 
			unless ($_ >=0 && $_ <= 1);
	}

        # Make  sure we  don't  try  to trim  away  more than  there
        # actually is.
	if ($trim[0] + $trim[2] > 1)
	{
		die("Trim values in X-Direction exceed image width.");
	}
	elsif ($trim[1] + $trim[3] > 1)
	{
		die("Trim values in Y-Direction exceed image height.");
	}
}


sub provide_output_dir
{
        # Create output directory if it does not yet exist.
	mkdir("output",0755) unless (-d "output");
}


sub grab_source_files
{
        # Find directories  in input,  check them  for image
        # files. Does not work recursively.


	my $img_files_ref   = shift;
	my $suffix_list_ref = shift;


	for my $img_file (@source_files)
	{
		if (-d $img_file)
		{
			for my $current_extension (@{ $suffix_list_ref })
			{
				while (<$img_file/*$current_extension>)
				{
					push @{ $img_files_ref }, $_;
				}
			}
		}
		else
		{
			push @{ $img_files_ref }, $img_file;
		}
	}

	return scalar(@{ $img_files_ref });
}

sub add_logo
{
	my $logo            = shift;
	my $target_w        = shift;
	my $target_h        = shift;
	my $logo_area_ratio = shift;
	my $output_file_ref = shift;


	# Load original logo file.
	my $gd_logo     = GD::Image->new($logo) or die;
	my $transparent = $gd_logo->colorAllocateAlpha(0,0,0,127);


	# Figure out how large the output logo needs to be.
	my ($logo_src_w, $logo_src_h) = $gd_logo->getBounds();
	my $logo_ratio = $logo_src_w / $logo_src_h;
	my $logo_w = sqrt($target_w 
		   * $target_h 
		   * $logo_area_ratio 
		   * $logo_ratio);
	my $logo_h = $logo_w / $logo_ratio;


	$gd_logo->interlaced('true');
	$gd_logo->alphaBlending(0);
	$gd_logo->saveAlpha(1);
	$gd_logo->transparent($transparent);


	# Create empty image for output logo.
	my $output_logo = GD::Image->new($logo_w, $logo_w);
	$output_logo->interlaced('true');
	$output_logo->alphaBlending(0);
	$output_logo->saveAlpha(1);
	$output_logo->transparent($transparent);


	# Copy logo into logo output file...
	$output_logo->copyResampled(
		$gd_logo,
		0,
		0,
		0,
		0,
		$logo_w,
		$logo_h,
		$logo_src_w,
		$logo_src_h
	);


	# ...and merge the result back into main image.
	${ $output_file_ref }->copyMerge(
		$output_logo,
		$target_w - $logo_w,
		$target_h - $logo_h,
		0,
		0,
		$logo_w,
		$logo_h,
		40
	);
}

sub handle_overwrite
{
	my $filename  = shift;
	my $extension = shift;

	return $filename if ($overwrite);

        # Prevent  overwriting  of  existing  files,  rename
        # current file if necessary. Numbered sequentally.
	if (-f "output/" . $filename . $extension)
	{
		my $duplicate_counter = 1;
		my $new_filename = $filename . "_" . $duplicate_counter;
		while (-f "output/" . $new_filename . $extension)
		{
			++$duplicate_counter;
			$new_filename = $filename . "_" . $duplicate_counter;
		}
		$filename = $new_filename;
	}
	return $filename;
}


sub write_output_file
{
	my $filename        = shift;
	my $extension       = shift;
	my $output_file_ref = shift;

	# Write to file.
	open(GD, ">output/" . $filename . $extension) or die;
	binmode GD;
	if ($extension eq ".jpeg" | $extension eq ".jpg")
	{
		print GD ${ $output_file_ref }->jpeg(80);
	}
	elsif ($extension eq ".png")
	{
		print GD ${ $output_file_ref }->png;
	}
	close GD;
}


sub process_images
{
	my $image_count     = shift;
	my $img_files_ref   = shift;
	my $desired_w       = shift;
	my $desired_h       = shift;
	my $suffix_list_ref = shift;

	my $counter         = 0;

	for my $img_file (@{ $img_files_ref })
	{
		my ($filename,$path,$extension) 
			= fileparse($img_file,@{ $suffix_list_ref });

		my $target_w;
		my $target_h;
		$target_w = $desired_w unless (!$desired_w);
		$target_h = $desired_h unless (!$desired_h);


		++$counter;
		my $length = length $image_count;
		my $status = sprintf("[ % ${length}u / %u ]    Processing %s",
			$counter,
			$image_count,
			$img_file
		);
		say $status;


		GD::Image->trueColor(1);


		my $gd_source = GD::Image->new($img_file) 
			or die("Fatal error, could not convert: " . $img_file);
		my ($source_w, $source_h) = $gd_source->getBounds();
		my $trimmed_src_w = $source_w * (1 - $trim[1] - $trim[3]);
		my $trimmed_src_h = $source_h * (1 - $trim[0] - $trim[2]);


		# Determine  target  dimensions  if  not  explicitly
		# defined by command line:
		my $ratio = $trimmed_src_w / $trimmed_src_h;
		if (!$target_w && !$target_h)
		{
			# If neither target  width nor target height
			# have	been specified,  keep dimensions  of
			# original image (or the trimmed area).
			$target_w = $trimmed_src_w;
			$target_h = $trimmed_src_h;
		}
		elsif (!$target_w)
		{
			# If target height but	not target width has
			# been	specified,  determine  target  width
			# based  on  height   and  aspect  ratio  of
			# source...
			$target_w = $target_h * $ratio;
		}
		elsif (!$target_h)
		{
			# ... or vice versa.
			$target_h = $target_w / $ratio;
		}


		$gd_source->interlaced('true');
		$gd_source->alphaBlending(0);
		$gd_source->saveAlpha(1);


		my $output_file = GD::Image->new($target_w, $target_h);
		$output_file->interlaced('true');
		$output_file->alphaBlending(0);
		$output_file->saveAlpha(1);


		my $src_x = $trim[3] * $source_w;
		my $src_y = $trim[0] * $source_h;


		$output_file->copyResampled(
			$gd_source,       # $srcImage
			0,                # $dstX
			0,                # $dstY
			$src_x,           # $srcX
			$src_y,           # $srcY
			$target_w,        # $destW
			$target_h,        # $destH
			$trimmed_src_w,   # $srcW
			$trimmed_src_h,   # $srcH
		);


		add_logo(
			$logo,
			$target_w,
			$target_h,
			$logo_area_ratio,
			\$output_file
		) if ($logo);


		$filename = handle_overwrite($filename, $extension);

		write_output_file($filename, $extension, \$output_file);
	}
}


get_input_args();
validate_trim_factors();
provide_output_dir();
process_images(
	grab_source_files(     # returns img_count
		\@IMG_FILES,
		\@SUFFIX_LIST
	),
	\@IMG_FILES,
	$DESIRED_W, 
	$DESIRED_H,
	\@SUFFIX_LIST
);
