#!/usr/bin/perl
use warnings;
use strict;

use 5.10.0;
use GD;
use GD::Text::Align;
use File::Basename;		# dirname(),fileparse(),basename()
use Getopt::Long;


my $logo;
my $desired_w;
my $desired_h;
my @source_files;
my @trim; # Trim factors: (top, right, bottom, left)


# TODO: refactor
#       add capability to specify output file format
#       add capability to specify logo size
#       add capability to specify logo placement


# Based on a square logo 1/10 the width of a 1.5/1 image:
my $logo_area_ratio = 0.0225;


my $arg_parser = Getopt::Long::Parser->new();
$arg_parser->getoptions(
	"logo|l=s"     => \$logo,
	"width|w=i"    => \$desired_w,
	"height|h=i"   => \$desired_h,
	"files|f=s{,}" => \@source_files,
	"trim|t=s{,}"  => \@trim
) or die ("Insufficient arguments");


die("No image files specified.") unless (@source_files);


# Validate trim array...
if (scalar(@trim) == 0)
{
	@trim=(0,0,0,0);
}

if (scalar(@trim) < 4)
{
	say "NOTE: Too few trim arguments specified. "
	  . "Assuming zero for unspecified elements. ";

	# Pad array with zeroes.
	push @trim, 0 until (scalar(@trim) == 4);
}
elsif (scalar(@trim > 4))
{
	say "NOTE: Too many trim arguments specified. "
	  . "Removing excess elements. ";

	# Remove excess elements.
	pop @trim until (scalar(@trim) == 4);
}

foreach (@trim)
{
	# Trim values are relative  to image size, so values
	# between 0 and 1 make sense.
	die("Trim values must be between 0 and 1, invalid range specified.") 
		unless ($_ >=0 && $_ <= 1);
}

# Make	sure we  don't	try  to trim  away  more than  there
# actually is.
if ($trim[0] + $trim[2] > 1)
{
	die("Trim values in X-Direction exceed image width.");
}
elsif ($trim[1] + $trim[3] > 1)
{
	die("Trim values in Y-Direction exceed image height.");
}


my $counter	= 0;
my @suffix_list = (".jpeg",".png",".jpg");
my @img_files;


# Create output directory if it does not yet exist.
mkdir("output",0755) unless (-d "output");

# Find	 directories  in   input,  check   them  for   image
# files. Does not work recursively.
for my $img_file (@source_files)
{
	if (-d $img_file)
	{
		for my $current_extension (@suffix_list)
		{
			while (<$img_file/*$current_extension>)
			{
				push @img_files, $_;
			}
		}
	}
	else
	{
		push @img_files, $img_file;
	}
}


my $image_count = scalar(@img_files);


for my $img_file (@img_files)
{
	my ($filename,$path,$extension) = fileparse($img_file,@suffix_list);
	my $target_w;
	my $target_h;

	$target_w = $desired_w unless (!$desired_w);
	$target_h = $desired_h unless (!$desired_h);


	++$counter;
	my $length = length $image_count;
	my $status = sprintf("[ % ${length}u / %u ]    Processing %s",
		$counter,
		$image_count,
		$img_file
	);
	say $status;


	GD::Image->trueColor(1);


	my $gd_source = GD::Image->new($img_file) 
		or die("Fatal error, could not convert: " . $img_file);
	my ($source_w, $source_h) = $gd_source->getBounds();
	my $trimmed_src_w = $source_w * (1 - $trim[1] - $trim[3]);
	my $trimmed_src_h = $source_h * (1 - $trim[0] - $trim[2]);


	# Determine  target  dimensions  if  not  explicitly
	# defined by command line:
	my $ratio = $trimmed_src_w / $trimmed_src_h;
	if (!$target_w && !$target_h)
	{
		# If neither target  width nor target height
		# have	been specified,  keep dimensions  of
		# original image (or the trimmed area).
		$target_w = $trimmed_src_w;
		$target_h = $trimmed_src_h;
	}
	elsif (!$target_w)
	{
		# If target height but	not target width has
		# been	specified,  determine  target  width
		# based  on  height   and  aspect  ratio  of
		# source...
		$target_w = $target_h * $ratio;
	}
	elsif (!$target_h)
	{
		# ... or vice versa.
		$target_h = $target_w / $ratio;
	}


	my $gd_logo;
	my $output_logo;
	my $logo_w;
	my $logo_h;
	my $logo_src_w;
	my $logo_src_h;
	my $logo_ratio;
	if ($logo)
	{
		# Grab logo if specified,  adjust in size to
		# overall image.

		$gd_logo	   = GD::Image->new($logo) or die;
		my $transparent    = $gd_logo->colorAllocateAlpha(0,0,0,127);

		($logo_src_w, $logo_src_h) = $gd_logo->getBounds();
		$logo_ratio = $logo_src_w / $logo_src_h;

		$logo_w = sqrt($target_w 
		        * $target_h 
		        * $logo_area_ratio 
		        * $logo_ratio);
		$logo_h = $logo_w / $logo_ratio;

		$gd_logo->interlaced('true');
		$gd_logo->alphaBlending(0);
		$gd_logo->saveAlpha(1);
		$gd_logo->transparent($transparent);

		$output_logo = GD::Image->new($logo_w, $logo_w);
		$output_logo->interlaced('true');
		$output_logo->alphaBlending(0);
		$output_logo->saveAlpha(1);
		$output_logo->transparent($transparent);

		$output_logo->copyResampled(
		        $gd_logo,
		        0,
		        0,
		        0,
		        0,
		        $logo_w,
		        $logo_h,
		        $logo_src_w,
		        $logo_src_h
		);
	}


	$gd_source->interlaced('true');
	$gd_source->alphaBlending(0);
	$gd_source->saveAlpha(1);


	my $output_file = GD::Image->new($target_w, $target_h);
	$output_file->interlaced('true');
	$output_file->alphaBlending(0);
	$output_file->saveAlpha(1);

	my $src_x = $trim[3] * $source_w;
	my $src_y = $trim[0] * $source_h;

	$output_file->copyResampled(
	        $gd_source,       # $srcImage
	        0,                # $dstX
	        0,                # $dstY
	        $src_x,           # $srcX
	        $src_y,           # $srcY
	        $target_w,        # $destW
	        $target_h,        # $destH
	        $trimmed_src_w,   # $srcW
	        $trimmed_src_h,   # $srcH
	);


	# Merge logo into main image.
	if ($logo)
	{
		$output_file->copyMerge(
			$output_logo,
			$target_w - $logo_w,
			$target_h - $logo_h,
			0,
			0,
			$logo_w,
			$logo_h,
			40
		);
	}


	# Prevent  overwriting	of  existing  files,  rename
	# current file if necessary. Numbered sequentally.
	if (-f "output/" . $filename . $extension)
	{
		my $duplicate_counter = 1;
		my $new_filename = $filename . "_" . $duplicate_counter;
		while (-f "output/" . $new_filename . $extension)
		{
			++$duplicate_counter;
			$new_filename = $filename . "_" . $duplicate_counter;
		}
		$filename = $new_filename;
	}


	# Write to file.
	open(GD, ">output/" . $filename . $extension) or die;
	binmode GD;
	if ($extension eq ".jpeg" | $extension eq ".jpg")
	{
		print GD $output_file->jpeg(80);
	}
	elsif ($extension eq ".png")
	{
		print GD $output_file->png;
	}
	close GD;
}
